"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const cache_1=__importDefault(require("./cache")),error_classes_1=require("./compile/error_classes"),rules_1=require("./compile/rules"),dataType_1=require("./compile/validate/dataType"),compile_1=require("./compile"),codegen_1=require("./compile/codegen"),resolve_1=require("./compile/resolve"),core_1=__importDefault(require("./vocabularies/core")),validation_1=__importDefault(require("./vocabularies/validation")),applicator_1=__importDefault(require("./vocabularies/applicator")),format_1=__importDefault(require("./vocabularies/format")),metadata_1=require("./vocabularies/metadata"),fast_json_stable_stringify_1=__importDefault(require("fast-json-stable-stringify")),util_1=require("./compile/util"),data_json_1=__importDefault(require("./refs/data.json")),json_schema_draft_07_json_1=__importDefault(require("./refs/json-schema-draft-07.json")),META_SCHEMA_ID="http://json-schema.org/draft-07/schema",META_IGNORE_OPTIONS=["removeAdditional","useDefaults","coerceTypes"],META_SUPPORT_DATA=["/properties"],EXT_SCOPE_NAMES=new Set(["validate","wrapper","root","schema","keyword","pattern","formats","validate$data","func","Error"]),optsDefaults={strict:!0,code:{},loopRequired:1/0,loopEnum:1/0,addUsedSchema:!0};class Ajv{constructor(e={}){var t,a,s;this.scope=new codegen_1.ValueScope({scope:{},prefixes:EXT_SCOPE_NAMES}),this.schemas={},this.refs={},this.formats={},this._compilations=new Set,this._loading={},e=this.opts={...optsDefaults,...e,serialize:!1===e.serialize?e=>e:null!==(t=e.serialize)&&void 0!==t?t:fast_json_stable_stringify_1.default,addUsedSchema:null===(a=e.addUsedSchema)||void 0===a||a,validateSchema:null===(s=e.validateSchema)||void 0===s||s},this.logger=getLogger(e.logger);const r=e.format;e.format=!1,this._cache=e.cache||new cache_1.default,this.RULES=rules_1.getRules(),checkDeprecatedOptions.call(this,e),this._metaOpts=getMetaSchemaOptions.call(this),e.formats&&addInitialFormats.call(this),this.addVocabulary(["$async"]),this.addVocabulary(core_1.default),this.addVocabulary(validation_1.default),this.addVocabulary(applicator_1.default),this.addVocabulary(format_1.default),this.addVocabulary(metadata_1.metadataVocabulary),this.addVocabulary(metadata_1.contentVocabulary),e.keywords&&addInitialKeywords.call(this,e.keywords),addDefaultMetaSchema.call(this),"object"==typeof e.meta&&this.addMetaSchema(e.meta),addInitialSchemas.call(this),e.format=r}validate(e,t){let a;if("string"==typeof e){if(!(a=this.getSchema(e)))throw new Error('no schema with key or ref "'+e+'"')}else{const t=this._addSchema(e);a=t.validate||this._compileSchemaEnv(t)}const s=a(t);return!0!==a.$async&&(this.errors=a.errors),s}compile(e,t){const a=this._addSchema(e,t);return a.validate||this._compileSchemaEnv(a)}compileAsync(e,t){if("function"!=typeof this.opts.loadSchema)throw new Error("options.loadSchema should be a function");const{loadSchema:a}=this.opts;return s.call(this,e,t);async function s(e,s){await r.call(this,e.$schema);const i=this._addSchema(e,s);return i.validate||async function e(s){try{return this._compileSchemaEnv(s)}catch(i){if(!(i instanceof error_classes_1.MissingRefError))throw i;return function({missingSchema:e,missingRef:t}){if(this.refs[e])throw new Error(`Schema ${e} is loaded but ${t} cannot be resolved`)}.call(this,i),await async function(e){const s=await async function(e){const t=this._loading[e];if(t)return t;try{return await(this._loading[e]=a(e))}finally{delete this._loading[e]}}.call(this,e);this.refs[e]||await r.call(this,s.$schema);this.refs[e]||this.addSchema(s,e,t)}.call(this,i.missingSchema),e.call(this,s)}}.call(this,i)}async function r(e){e&&!this.getSchema(e)&&await s.call(this,{$ref:e},!0)}}addSchema(e,t,a,s=this.opts.validateSchema){if(Array.isArray(e)){for(const t of e)this.addSchema(t,void 0,a,s);return this}let r;if("object"==typeof e&&void 0!==(r=e.$id)&&"string"!=typeof r)throw new Error("schema id must be string");return t=resolve_1.normalizeId(t||r),this._checkUnique(t),this.schemas[t]=this._addSchema(e,a,s,!0),this}addMetaSchema(e,t,a=this.opts.validateSchema){return this.addSchema(e,t,!0,a),this}validateSchema(e,t){if("boolean"==typeof e)return!0;let a;if(void 0!==(a=e.$schema)&&"string"!=typeof a)throw new Error("$schema must be a string");if(!(a=a||this.opts.defaultMeta||defaultMeta.call(this)))return this.logger.warn("meta-schema not available"),this.errors=null,!0;const s=this.validate(a,e);if(!s&&t){const e="schema is invalid: "+this.errorsText();if("log"!==this.opts.validateSchema)throw new Error(e);this.logger.error(e)}return s}getSchema(e){let t;for(;"string"==typeof(t=getSchEnv.call(this,e));)e=t;if(void 0===t){const a=new compile_1.SchemaEnv({schema:{}});if(!(t=compile_1.resolveSchema.call(this,a,e)))return;this.refs[e]=t}return t.validate||this._compileSchemaEnv(t)}removeSchema(e){if(e instanceof RegExp)return this._removeAllSchemas(this.schemas,e),this._removeAllSchemas(this.refs,e),this;switch(typeof e){case"undefined":return this._removeAllSchemas(this.schemas),this._removeAllSchemas(this.refs),this._cache.clear(),this;case"string":{const t=getSchEnv.call(this,e);return"object"==typeof t&&this._cache.del(t.cacheKey),delete this.schemas[e],delete this.refs[e],this}case"object":{const t=this.opts.serialize(e);this._cache.del(t);let a=e.$id;return a&&(a=resolve_1.normalizeId(a),delete this.schemas[a],delete this.refs[a]),this}default:throw new Error("ajv.removeSchema: invalid parameter")}}addVocabulary(e){for(const t of e)this.addKeyword(t);return this}addKeyword(e,t){let a;if("string"==typeof e)a=e,"object"==typeof t&&(this.logger.warn("these parameters are deprecated, see docs for addKeyword"),t.keyword=a);else{if("object"!=typeof e||void 0!==t)throw new Error("invalid addKeywords parameters");a=(t=e).keyword}return checkKeyword.call(this,a,t),t&&keywordMetaschema.call(this,t),util_1.eachItem(a,e=>{util_1.eachItem(null==t?void 0:t.type,a=>addRule.call(this,e,a,t))}),this}getKeyword(e){const t=this.RULES.all[e];return"object"==typeof t?t.definition:!!t}removeKeyword(e){const{RULES:t}=this;delete t.keywords[e],delete t.all[e];for(const a of t.rules){const t=a.rules.findIndex(t=>t.keyword===e);t>=0&&a.rules.splice(t,1)}return this}addFormat(e,t){return"string"==typeof t&&(t=new RegExp(t)),this.formats[e]=t,this}errorsText(e=this.errors,{separator:t=", ",dataVar:a="data"}={}){return e&&0!==e.length?e.map(e=>`${a}${e.dataPath} ${e.message}`).reduce((e,a)=>e+a+t):"No errors"}$dataMetaSchema(e,t){const a=this.RULES.all;for(const s of t){e=JSON.parse(JSON.stringify(e));const t=s.split("/").slice(1);let r=e;for(const e of t)r=r[e];for(const e in a){const t=a[e];if("object"!=typeof t)continue;const{$data:s}=t.definition,i=r[e];s&&i&&(r[e]=schemaOrData(i))}}return e}_removeAllSchemas(e,t){for(const a in e){const s=e[a];t&&!t.test(a)||("string"==typeof s?delete e[a]:s&&!s.meta&&(this._cache.del(s.cacheKey),delete e[a]))}}_addSchema(e,t,a=this.opts.validateSchema,s=this.opts.addUsedSchema){if("object"!=typeof e&&"boolean"!=typeof e)throw new Error("schema must be object or boolean");const r=this.opts.serialize(e);let i=this._cache.get(r);if(i)return i;const o=resolve_1.getSchemaRefs.call(this,e);i=new compile_1.SchemaEnv({schema:e,cacheKey:r,meta:t,localRefs:o}),this._cache.put(i.cacheKey,i);const c=i.baseId;return s&&!c.startsWith("#")&&(c&&this._checkUnique(c),this.refs[c]=i),a&&this.validateSchema(e,!0),i}_checkUnique(e){if(this.schemas[e]||this.refs[e])throw new Error(`schema with key or id "${e}" already exists`)}_compileSchemaEnv(e){if(e.meta?this._compileMetaSchema(e):compile_1.compileSchema.call(this,e),!e.validate)throw new Error("ajv implementation error");return e.validate}_compileMetaSchema(e){const t=this.opts;this.opts=this._metaOpts;try{compile_1.compileSchema.call(this,e)}finally{this.opts=t}}}function checkDeprecatedOptions(e){void 0!==e.errorDataPath&&this.logger.error("NOT SUPPORTED: option errorDataPath"),void 0!==e.schemaId&&this.logger.error("NOT SUPPORTED: option schemaId"),void 0!==e.uniqueItems&&this.logger.error("NOT SUPPORTED: option uniqueItems"),void 0!==e.jsPropertySyntax&&this.logger.warn("DEPRECATED: option jsPropertySyntax"),void 0!==e.unicode&&this.logger.warn("DEPRECATED: option unicode")}function defaultMeta(){const{meta:e}=this.opts;return this.opts.defaultMeta="object"==typeof e?e.$id||e:this.getSchema(META_SCHEMA_ID)?META_SCHEMA_ID:void 0,this.opts.defaultMeta}function getSchEnv(e){return e=resolve_1.normalizeId(e),this.schemas[e]||this.refs[e]}function addDefaultMetaSchema(){const{$data:e,meta:t}=this.opts;if(e&&this.addMetaSchema(data_json_1.default,data_json_1.default.$id,!1),!1===t)return;const a=e?this.$dataMetaSchema(json_schema_draft_07_json_1.default,META_SUPPORT_DATA):json_schema_draft_07_json_1.default;this.addMetaSchema(a,META_SCHEMA_ID,!1),this.refs["http://json-schema.org/schema"]=META_SCHEMA_ID}function addInitialSchemas(){const e=this.opts.schemas;if(e)if(Array.isArray(e))this.addSchema(e);else for(const t in e)this.addSchema(e[t],t)}function addInitialFormats(){for(const e in this.opts.formats){const t=this.opts.formats[e];this.addFormat(e,t)}}function addInitialKeywords(e){if(Array.isArray(e))this.addVocabulary(e);else{this.logger.warn("keywords option as map is deprecated, pass array");for(const t in e){const a=e[t];a.keyword||(a.keyword=t),this.addKeyword(a)}}}function getMetaSchemaOptions(){const e={...this.opts};for(const t of META_IGNORE_OPTIONS)delete e[t];return e}exports.default=Ajv,Ajv.ValidationError=error_classes_1.ValidationError,Ajv.MissingRefError=error_classes_1.MissingRefError;const noLogs={log(){},warn(){},error(){}};function getLogger(e){if(!1===e)return noLogs;if(void 0===e)return console;if(e.log&&e.warn&&e.error)return e;throw new Error("logger must implement log, warn and error methods")}const KEYWORD_NAME=/^[a-z_$][a-z0-9_$-]*$/i;function checkKeyword(e,t){const{RULES:a}=this;if(util_1.eachItem(e,e=>{if(a.keywords[e])throw new Error(`Keyword ${e} is already defined`);if(!KEYWORD_NAME.test(e))throw new Error(`Keyword ${e} has invalid name`)}),t&&(t.type&&util_1.eachItem(t.type,e=>dataType_1.checkType(e,a)),t.$data&&!("code"in t||"validate"in t)))throw new Error('$data keyword must have "code" or "validate" function')}function addRule(e,t,a){var s;const{RULES:r}=this;let i=r.rules.find(({type:e})=>e===t);if(i||(i={type:t,rules:[]},r.rules.push(i)),r.keywords[e]=!0,!a)return;const o={keyword:e,definition:a};a.before?addBeforeRule.call(this,i,o,a.before):i.rules.push(o),r.all[e]=o,null===(s=a.implements)||void 0===s||s.forEach(e=>this.addKeyword(e))}function addBeforeRule(e,t,a){const s=e.rules.findIndex(e=>e.keyword===a);s>=0?e.rules.splice(s,0,t):(e.rules.push(t),this.logger.warn(`rule ${a} is not defined`))}function keywordMetaschema(e){let{metaSchema:t}=e;void 0!==t&&(e.$data&&this.opts.$data&&(t=schemaOrData(t)),e.validateSchema=this.compile(t,!0))}const $dataRef={$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"};function schemaOrData(e){return{anyOf:[e,$dataRef]}}module.exports=Ajv;