"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.applySubschema=exports.CodeGen=exports.Name=exports.nil=exports.stringify=exports.str=exports._=exports.KeywordCxt=void 0;const context_1=__importDefault(require("./compile/context"));exports.KeywordCxt=context_1.default;var codegen_1=require("./compile/codegen");Object.defineProperty(exports,"_",{enumerable:!0,get:function(){return codegen_1._}}),Object.defineProperty(exports,"str",{enumerable:!0,get:function(){return codegen_1.str}}),Object.defineProperty(exports,"stringify",{enumerable:!0,get:function(){return codegen_1.stringify}}),Object.defineProperty(exports,"nil",{enumerable:!0,get:function(){return codegen_1.nil}}),Object.defineProperty(exports,"Name",{enumerable:!0,get:function(){return codegen_1.Name}}),Object.defineProperty(exports,"CodeGen",{enumerable:!0,get:function(){return codegen_1.CodeGen}});var subschema_1=require("./compile/subschema");Object.defineProperty(exports,"applySubschema",{enumerable:!0,get:function(){return subschema_1.applySubschema}});const error_classes_1=require("./compile/error_classes"),rules_1=require("./compile/rules"),compile_1=require("./compile"),codegen_2=require("./compile/codegen"),resolve_1=require("./compile/resolve"),dataType_1=require("./compile/validate/dataType"),core_1=__importDefault(require("./vocabularies/core")),validation_1=__importDefault(require("./vocabularies/validation")),applicator_1=__importDefault(require("./vocabularies/applicator")),format_1=__importDefault(require("./vocabularies/format")),metadata_1=require("./vocabularies/metadata"),util_1=require("./compile/util"),data_json_1=__importDefault(require("./refs/data.json")),json_schema_draft_07_json_1=__importDefault(require("./refs/json-schema-draft-07.json")),META_SCHEMA_ID="http://json-schema.org/draft-07/schema",META_IGNORE_OPTIONS=["removeAdditional","useDefaults","coerceTypes"],META_SUPPORT_DATA=["/properties"],EXT_SCOPE_NAMES=new Set(["validate","wrapper","root","schema","keyword","pattern","formats","validate$data","func","Error"]),removedOptions={errorDataPath:"",format:"`validateFormats: false` can be used instead.",nullable:'"nullable" keyword is supported by default.',jsonPointers:"Deprecated jsPropertySyntax can be used instead.",extendRefs:"Deprecated ignoreKeywordsWithRef can be used instead.",missingRefs:"Pass empty schema with $id that should be ignored to ajv.addSchema.",processCode:"Use option `code: {process: (code, schemaEnv: object) => string}`",sourceCode:"Use option `code: {source: true}`",schemaId:"JSON Schema draft-04 is not supported in Ajv v7.",strictDefaults:"It is default now, see option `strict`.",strictKeywords:"It is default now, see option `strict`.",strictNumbers:"It is default now, see option `strict`.",uniqueItems:'"uniqueItems" keyword is always validated.',unknownFormats:"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",cache:"Map is used as cache, schema object as key.",serialize:"Map is used as cache, schema object as key."},deprecatedOptions={ignoreKeywordsWithRef:"",jsPropertySyntax:"",unicode:'"minLength"/"maxLength" account for unicode characters by default.'};function requiredOptions(e){var t,a,s,r,o,i,n,c,d,l,h,m;const u=null===(t=e.strict)||void 0===t||t,f=!!u&&"log";return{strict:u,strictTypes:null!==(a=e.strictTypes)&&void 0!==a?a:f,strictTuples:null!==(s=e.strictTuples)&&void 0!==s?s:f,code:null!==(r=e.code)&&void 0!==r?r:{},loopRequired:null!==(o=e.loopRequired)&&void 0!==o?o:1/0,loopEnum:null!==(i=e.loopEnum)&&void 0!==i?i:1/0,meta:null===(n=e.meta)||void 0===n||n,messages:null===(c=e.messages)||void 0===c||c,inlineRefs:null===(d=e.inlineRefs)||void 0===d||d,addUsedSchema:null===(l=e.addUsedSchema)||void 0===l||l,validateSchema:null===(h=e.validateSchema)||void 0===h||h,validateFormats:null===(m=e.validateFormats)||void 0===m||m}}class Ajv{constructor(e={}){this.scope=new codegen_2.ValueScope({scope:{},prefixes:EXT_SCOPE_NAMES}),this.schemas={},this.refs={},this.formats={},this._compilations=new Set,this._loading={},this._cache=new Map,e=this.opts={...e,...requiredOptions(e)},this.logger=getLogger(e.logger);const t=e.validateFormats;e.validateFormats=!1,this.RULES=rules_1.getRules(),checkOptions.call(this,removedOptions,e,"NOT SUPPORTED"),checkOptions.call(this,deprecatedOptions,e,"DEPRECATED","warn"),this._metaOpts=getMetaSchemaOptions.call(this),e.formats&&addInitialFormats.call(this),this.addVocabulary(["$async"]),this.addVocabulary(core_1.default),this.addVocabulary(validation_1.default),this.addVocabulary(applicator_1.default),this.addVocabulary(format_1.default),this.addVocabulary(metadata_1.metadataVocabulary),this.addVocabulary(metadata_1.contentVocabulary),e.keywords&&addInitialKeywords.call(this,e.keywords),addDefaultMetaSchema.call(this),"object"==typeof e.meta&&this.addMetaSchema(e.meta),addInitialSchemas.call(this),e.validateFormats=t}validate(e,t){let a;if("string"==typeof e){if(!(a=this.getSchema(e)))throw new Error('no schema with key or ref "'+e+'"')}else{const t=this._addSchema(e);a=t.validate||this._compileSchemaEnv(t)}const s=a(t);return"$async"in a||(this.errors=a.errors),s}compile(e,t){const a=this._addSchema(e,t);return a.validate||this._compileSchemaEnv(a)}compileAsync(e,t){if("function"!=typeof this.opts.loadSchema)throw new Error("options.loadSchema should be a function");const{loadSchema:a}=this.opts;return s.call(this,e,t);async function s(e,s){await r.call(this,e.$schema);const o=this._addSchema(e,s);return o.validate||async function e(s){try{return this._compileSchemaEnv(s)}catch(o){if(!(o instanceof error_classes_1.MissingRefError))throw o;return function({missingSchema:e,missingRef:t}){if(this.refs[e])throw new Error(`AnySchema ${e} is loaded but ${t} cannot be resolved`)}.call(this,o),await async function(e){const s=await async function(e){const t=this._loading[e];if(t)return t;try{return await(this._loading[e]=a(e))}finally{delete this._loading[e]}}.call(this,e);this.refs[e]||await r.call(this,s.$schema);this.refs[e]||this.addSchema(s,e,t)}.call(this,o.missingSchema),e.call(this,s)}}.call(this,o)}async function r(e){e&&!this.getSchema(e)&&await s.call(this,{$ref:e},!0)}}addSchema(e,t,a,s=this.opts.validateSchema){if(Array.isArray(e)){for(const t of e)this.addSchema(t,void 0,a,s);return this}let r;if("object"==typeof e&&void 0!==(r=e.$id)&&"string"!=typeof r)throw new Error("schema id must be string");return t=resolve_1.normalizeId(t||r),this._checkUnique(t),this.schemas[t]=this._addSchema(e,a,s,!0),this}addMetaSchema(e,t,a=this.opts.validateSchema){return this.addSchema(e,t,!0,a),this}validateSchema(e,t){if("boolean"==typeof e)return!0;let a;if(void 0!==(a=e.$schema)&&"string"!=typeof a)throw new Error("$schema must be a string");if(!(a=a||this.opts.defaultMeta||defaultMeta.call(this)))return this.logger.warn("meta-schema not available"),this.errors=null,!0;const s=this.validate(a,e);if(!s&&t){const e="schema is invalid: "+this.errorsText();if("log"!==this.opts.validateSchema)throw new Error(e);this.logger.error(e)}return s}getSchema(e){let t;for(;"string"==typeof(t=getSchEnv.call(this,e));)e=t;if(void 0===t){const a=new compile_1.SchemaEnv({schema:{}});if(!(t=compile_1.resolveSchema.call(this,a,e)))return;this.refs[e]=t}return t.validate||this._compileSchemaEnv(t)}removeSchema(e){if(e instanceof RegExp)return this._removeAllSchemas(this.schemas,e),this._removeAllSchemas(this.refs,e),this;switch(typeof e){case"undefined":return this._removeAllSchemas(this.schemas),this._removeAllSchemas(this.refs),this._cache.clear(),this;case"string":{const t=getSchEnv.call(this,e);return"object"==typeof t&&this._cache.delete(t.schema),delete this.schemas[e],delete this.refs[e],this}case"object":{const t=e;this._cache.delete(t);let a=e.$id;return a&&(a=resolve_1.normalizeId(a),delete this.schemas[a],delete this.refs[a]),this}default:throw new Error("ajv.removeSchema: invalid parameter")}}addVocabulary(e){for(const t of e)this.addKeyword(t);return this}addKeyword(e,t){let a;if("string"==typeof e)a=e,"object"==typeof t&&(this.logger.warn("these parameters are deprecated, see docs for addKeyword"),t.keyword=a);else{if("object"!=typeof e||void 0!==t)throw new Error("invalid addKeywords parameters");if(a=(t=e).keyword,Array.isArray(a)&&!a.length)throw new Error("addKeywords: keyword must be non-empty array")}if(checkKeyword.call(this,a,t),!t)return util_1.eachItem(a,e=>addRule.call(this,e)),this;keywordMetaschema.call(this,t);const s={...t,type:dataType_1.getJSONTypes(t.type),schemaType:dataType_1.getJSONTypes(t.schemaType)};return util_1.eachItem(a,0===s.type.length?e=>addRule.call(this,e,s):e=>s.type.forEach(t=>addRule.call(this,e,s,t))),this}getKeyword(e){const t=this.RULES.all[e];return"object"==typeof t?t.definition:!!t}removeKeyword(e){const{RULES:t}=this;delete t.keywords[e],delete t.all[e];for(const a of t.rules){const t=a.rules.findIndex(t=>t.keyword===e);t>=0&&a.rules.splice(t,1)}return this}addFormat(e,t){return"string"==typeof t&&(t=new RegExp(t)),this.formats[e]=t,this}errorsText(e=this.errors,{separator:t=", ",dataVar:a="data"}={}){return e&&0!==e.length?e.map(e=>`${a}${e.dataPath} ${e.message}`).reduce((e,a)=>e+t+a):"No errors"}$dataMetaSchema(e,t){const a=this.RULES.all;e=JSON.parse(JSON.stringify(e));for(const s of t){const t=s.split("/").slice(1);let r=e;for(const e of t)r=r[e];for(const e in a){const t=a[e];if("object"!=typeof t)continue;const{$data:s}=t.definition,o=r[e];s&&o&&(r[e]=schemaOrData(o))}}return e}_removeAllSchemas(e,t){for(const a in e){const s=e[a];t&&!t.test(a)||("string"==typeof s?delete e[a]:s&&!s.meta&&(this._cache.delete(s.schema),delete e[a]))}}_addSchema(e,t,a=this.opts.validateSchema,s=this.opts.addUsedSchema){if("object"!=typeof e&&"boolean"!=typeof e)throw new Error("schema must be object or boolean");let r=this._cache.get(e);if(void 0!==r)return r;const o=resolve_1.getSchemaRefs.call(this,e);r=new compile_1.SchemaEnv({schema:e,meta:t,localRefs:o}),this._cache.set(r.schema,r);const i=r.baseId;return s&&!i.startsWith("#")&&(i&&this._checkUnique(i),this.refs[i]=r),a&&this.validateSchema(e,!0),r}_checkUnique(e){if(this.schemas[e]||this.refs[e])throw new Error(`schema with key or id "${e}" already exists`)}_compileSchemaEnv(e){if(e.meta?this._compileMetaSchema(e):compile_1.compileSchema.call(this,e),!e.validate)throw new Error("ajv implementation error");return e.validate}_compileMetaSchema(e){const t=this.opts;this.opts=this._metaOpts;try{compile_1.compileSchema.call(this,e)}finally{this.opts=t}}}function checkOptions(e,t,a,s="error"){for(const r in e){const o=r;o in t&&this.logger[s](`${a}: option ${r}. ${e[o]}`)}}function defaultMeta(){const{meta:e}=this.opts;return this.opts.defaultMeta="object"==typeof e?e.$id||e:this.getSchema(META_SCHEMA_ID)?META_SCHEMA_ID:void 0,this.opts.defaultMeta}function getSchEnv(e){return e=resolve_1.normalizeId(e),this.schemas[e]||this.refs[e]}function addDefaultMetaSchema(){const{$data:e,meta:t}=this.opts;if(e&&this.addMetaSchema(data_json_1.default,data_json_1.default.$id,!1),!t)return;const a=e?this.$dataMetaSchema(json_schema_draft_07_json_1.default,META_SUPPORT_DATA):json_schema_draft_07_json_1.default;this.addMetaSchema(a,META_SCHEMA_ID,!1),this.refs["http://json-schema.org/schema"]=META_SCHEMA_ID}function addInitialSchemas(){const e=this.opts.schemas;if(e)if(Array.isArray(e))this.addSchema(e);else for(const t in e)this.addSchema(e[t],t)}function addInitialFormats(){for(const e in this.opts.formats){const t=this.opts.formats[e];this.addFormat(e,t)}}function addInitialKeywords(e){if(Array.isArray(e))this.addVocabulary(e);else{this.logger.warn("keywords option as map is deprecated, pass array");for(const t in e){const a=e[t];a.keyword||(a.keyword=t),this.addKeyword(a)}}}function getMetaSchemaOptions(){const e={...this.opts};for(const t of META_IGNORE_OPTIONS)delete e[t];return e}exports.default=Ajv,Ajv.ValidationError=error_classes_1.ValidationError,Ajv.MissingRefError=error_classes_1.MissingRefError;const noLogs={log(){},warn(){},error(){}};function getLogger(e){if(!1===e)return noLogs;if(void 0===e)return console;if(e.log&&e.warn&&e.error)return e;throw new Error("logger must implement log, warn and error methods")}const KEYWORD_NAME=/^[a-z_$][a-z0-9_$-]*$/i;function checkKeyword(e,t){const{RULES:a}=this;if(util_1.eachItem(e,e=>{if(a.keywords[e])throw new Error(`Keyword ${e} is already defined`);if(!KEYWORD_NAME.test(e))throw new Error(`Keyword ${e} has invalid name`)}),t&&t.$data&&!("code"in t||"validate"in t))throw new Error('$data keyword must have "code" or "validate" function')}function addRule(e,t,a){var s;const{RULES:r}=this;let o=r.rules.find(({type:e})=>e===a);if(o||(o={type:a,rules:[]},r.rules.push(o)),r.keywords[e]=!0,!t)return;const i={keyword:e,definition:{...t,type:dataType_1.getJSONTypes(t.type),schemaType:dataType_1.getJSONTypes(t.schemaType)}};t.before?addBeforeRule.call(this,o,i,t.before):o.rules.push(i),r.all[e]=i,null===(s=t.implements)||void 0===s||s.forEach(e=>this.addKeyword(e))}function addBeforeRule(e,t,a){const s=e.rules.findIndex(e=>e.keyword===a);s>=0?e.rules.splice(s,0,t):(e.rules.push(t),this.logger.warn(`rule ${a} is not defined`))}function keywordMetaschema(e){let{metaSchema:t}=e;void 0!==t&&(e.$data&&this.opts.$data&&(t=schemaOrData(t)),e.validateSchema=this.compile(t,!0))}const $dataRef={$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"};function schemaOrData(e){return{anyOf:[e,$dataRef]}}module.exports=Ajv,module.exports.default=Ajv;